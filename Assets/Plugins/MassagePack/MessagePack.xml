<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MessagePack</name>
    </assembly>
    <members>
        <member name="T:System.Numerics.BitOperations">
            <summary>
            Utility methods for intrinsic bit-twiddling operations.
            The methods use hardware intrinsics when available on the underlying platform,
            otherwise they use optimized software fallbacks.
            </summary>
        </member>
        <member name="M:System.Numerics.BitOperations.RotateLeft(System.UInt32,System.Int32)">
            <summary>
            Rotates the specified value left by the specified number of bits.
            Similar in behavior to the x86 instruction ROL.
            </summary>
            <param name="value">The value to rotate.</param>
            <param name="offset">The number of bits to rotate by.
            Any value outside the range [0..31] is treated as congruent mod 32.</param>
            <returns>The rotated value.</returns>
        </member>
        <member name="T:MessagePack.Formatters.CollectionHelpers`2">
            <summary>
            Provides general helpers for creating collections (including dictionaries).
            </summary>
            <typeparam name="TCollection">The concrete type of collection to create.</typeparam>
            <typeparam name="TEqualityComparer">The type of equality comparer that we would hope to pass into the collection's constructor.</typeparam>
        </member>
        <member name="F:MessagePack.Formatters.CollectionHelpers`2.collectionCreator">
            <summary>
            The delegate that will create the collection, if the typical (int count, IEqualityComparer{T} equalityComparer) constructor was found.
            </summary>
        </member>
        <member name="M:MessagePack.Formatters.CollectionHelpers`2.#cctor">
            <summary>
            Initializes static members of the <see cref="T:MessagePack.Formatters.CollectionHelpers`2"/> class.
            </summary>
            <remarks>
            Initializes a delegate that is optimized to create a collection of a given size and using the given equality comparer, if possible.
            </remarks>
        </member>
        <member name="M:MessagePack.Formatters.CollectionHelpers`2.CreateHashCollection(System.Int32,`1)">
            <summary>
            Initializes a new instance of the <typeparamref name="TCollection"/> collection.
            </summary>
            <param name="count">The number of elements the collection should be prepared to receive.</param>
            <param name="equalityComparer">The equality comparer to initialize the collection with.</param>
            <returns>The newly initialized collection.</returns>
            <remarks>
            Use of the <paramref name="count"/> and <paramref name="equalityComparer"/> are a best effort.
            If we can't find a constructor on the collection in the expected shape, we'll just instantiate the collection with its default constructor.
            </remarks>
        </member>
        <member name="T:MessagePack.Formatters.NativeDateTimeFormatter">
            <summary>
            Serialize by .NET native DateTime binary format.
            </summary>
        </member>
        <member name="T:MessagePack.Formatters.DynamicObjectTypeFallbackFormatter">
            <summary>
            This formatter can serialize any value whose static type is <see cref="T:System.Object"/>
            for which another resolver can provide a formatter for the runtime type.
            Its deserialization is limited to forwarding all calls to the <see cref="T:MessagePack.Formatters.PrimitiveObjectFormatter"/>.
            </summary>
        </member>
        <member name="T:MessagePack.Formatters.IMessagePackFormatter">
            <summary>
            A base interface for <see cref="T:MessagePack.Formatters.IMessagePackFormatter`1"/> so that all generic implementations
            can be detected by a common base type.
            </summary>
        </member>
        <member name="T:MessagePack.Formatters.IMessagePackFormatter`1">
            <summary>
            The contract for serialization of some specific type.
            </summary>
            <typeparam name="T">The type to be serialized or deserialized.</typeparam>
        </member>
        <member name="M:MessagePack.Formatters.IMessagePackFormatter`1.Serialize(MessagePack.MessagePackWriter@,`0,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Serializes a value.
            </summary>
            <param name="writer">The writer to use when serializing the value.</param>
            <param name="value">The value to be serialized.</param>
            <param name="options">The serialization settings to use, including the resolver to use to obtain formatters for types that make up the composite type <typeparamref name="T"/>.</param>
        </member>
        <member name="M:MessagePack.Formatters.IMessagePackFormatter`1.Deserialize(MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Deserializes a value.
            </summary>
            <param name="reader">The reader to deserialize from.</param>
            <param name="options">The serialization settings to use, including the resolver to use to obtain formatters for types that make up the composite type <typeparamref name="T"/>.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="T:MessagePack.Formatters.ByteArrayFormatter">
            <summary>
            Serializes a <see cref="T:System.Byte"/> array as a bin type.
            Deserializes a bin type or an array of byte-sized integers into a <see cref="T:System.Byte"/> array.
            </summary>
        </member>
        <member name="T:MessagePack.Formatters.TypeFormatter`1">
            <summary>
            Serializes any instance of <see cref="T:System.Type"/> by its <see cref="P:System.Type.AssemblyQualifiedName"/> value.
            </summary>
            <typeparam name="T">The <see cref="T:System.Type"/> class itself or a derived type.</typeparam>
        </member>
        <member name="T:MessagePack.Formatters.StringInterningFormatter">
            <summary>
            A <see cref="T:System.String" /> formatter that interns strings on deserialization.
            </summary>
        </member>
        <member name="M:MessagePack.Formatters.StringInterningFormatter.Deserialize(MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="M:MessagePack.Formatters.StringInterningFormatter.Serialize(MessagePack.MessagePackWriter@,System.String,MessagePack.MessagePackSerializerOptions)">
            <inheritdoc/>
        </member>
        <member name="T:MessagePack.Formatters.ForceTypelessFormatter`1">
            <summary>
            Force serialize object as typeless.
            </summary>
        </member>
        <member name="T:MessagePack.Formatters.TypelessFormatter">
            <summary>
            For `object` field that holds derived from `object` value, ex: var arr = new object[] { 1, "a", new Model() };.
            </summary>
        </member>
        <member name="F:MessagePack.Formatters.TypelessFormatter.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="M:MessagePack.Formatters.TypelessFormatter.DeserializeByTypeName(System.ArraySegment{System.Byte},MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Does not support deserializing of anonymous types
            Type should be covered by preceeding resolvers in complex/standard resolver.
            </summary>
        </member>
        <member name="F:MessagePack.Formatters.NativeGuidFormatter.Instance">
            <summary>
            Unsafe binary Guid formatter. this is only allowed on LittleEndian environment.
            </summary>
        </member>
        <member name="F:MessagePack.Formatters.NativeDecimalFormatter.Instance">
            <summary>
            Unsafe binary Decimal formatter. this is only allows on LittleEndian environment.
            </summary>
        </member>
        <member name="T:MessagePack.Internal.AutomataDictionary">
            <remarks>
            This code is used by dynamically generated code as well as AOT generated code,
            and thus must be public for the "C# generated and compiled into saved assembly" scenario.
            </remarks>
        </member>
        <member name="T:MessagePack.Internal.AutomataKeyGen">
            <remarks>
            This is used by dynamically generated code. It can be made internal after we enable our dynamic assemblies to access internals.
            But that trick may require net46, so maybe we should leave this as public.
            </remarks>
        </member>
        <member name="T:MessagePack.Internal.CodeGenHelpers">
            <summary>
            Helpers for generated code.
            </summary>
            <remarks>
            This code is used by dynamically generated code as well as AOT generated code,
            and thus must be public for the "C# generated and compiled into saved assembly" scenario.
            </remarks>
        </member>
        <member name="M:MessagePack.Internal.CodeGenHelpers.GetEncodedStringBytes(System.String)">
            <summary>
            Gets the messagepack encoding for a given string.
            </summary>
            <param name="value">The string to encode.</param>
            <returns>The messagepack encoding for <paramref name="value"/>, including messagepack header and UTF-8 bytes.</returns>
        </member>
        <member name="M:MessagePack.Internal.CodeGenHelpers.GetSpanFromSequence(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Gets a single <see cref="T:System.ReadOnlySpan`1"/> containing all bytes in a given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            An array may be allocated if the bytes are not already contiguous in memory.
            </summary>
            <param name="sequence">The sequence to get a span for.</param>
            <returns>The span.</returns>
        </member>
        <member name="M:MessagePack.Internal.CodeGenHelpers.ReadStringSpan(MessagePack.MessagePackReader@)">
            <summary>
            Reads a string as a contiguous span of UTF-8 encoded characters.
            An array may be allocated if the string is not already contiguous in memory.
            </summary>
            <param name="reader">The reader to use.</param>
            <returns>The span of UTF-8 encoded characters.</returns>
        </member>
        <member name="M:MessagePack.Internal.CodeGenHelpers.GetArrayFromNullableSequence(System.Nullable{System.Buffers.ReadOnlySequence{System.Byte}}@)">
            <summary>
            Creates a <see cref="T:System.Byte"/> array for a given sequence, or <see langword="null" /> if the optional sequence is itself <see langword="null" />.
            </summary>
            <param name="sequence">The sequence.</param>
            <returns>The byte array or <see langword="null" /> .</returns>
        </member>
        <member name="M:MessagePack.Internal.ExpressionUtility.GetMethodInfo``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Get MethodInfo from Expression for Static(with result) method.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ExpressionUtility.GetMethodInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Get MethodInfo from Expression for Static(void) method.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ExpressionUtility.GetMethodInfo``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Get MethodInfo from Expression for Instance(with result) method.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ExpressionUtility.GetMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Get MethodInfo from Expression for Instance(void) method.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ExpressionUtility.GetMethodInfo``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Get MethodInfo from Expression for Instance(with result) method.
            </summary>
        </member>
        <member name="T:MessagePack.Internal.ILGeneratorExtensions">
            <summary>
            Provides optimized generation code and helpers.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ILGeneratorExtensions.EmitLdloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Loads the local variable at a specific index onto the evaluation stack.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ILGeneratorExtensions.EmitStloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ILGeneratorExtensions.EmitLdloca(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Loads the address of the local variable at a specific index onto the evaluation statck.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ILGeneratorExtensions.EmitLdc_I4(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Pushes a supplied value of type int32 onto the evaluation stack as an int32.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ILGeneratorExtensions.EmitPop(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Helper for Pop op.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ILGeneratorExtensions.EmitIncrementFor(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.LocalBuilder,System.Action{System.Reflection.Emit.LocalBuilder})">
            <summary>for  var i = 0, i ..., i++. </summary>
        </member>
        <member name="T:MessagePack.Internal.ThreadsafeTypeKeyHashTable`1">
            <summary>
            A dictionary where <see cref="T:System.Type"/> is the key, and a configurable <typeparamref name="TValue"/> type
            that is thread-safe to read and write, allowing concurrent reads and exclusive writes.
            </summary>
            <typeparam name="TValue">The type of value stored in the dictionary.</typeparam>
        </member>
        <member name="M:MessagePack.Internal.DynamicObjectTypeBuilder.Matches(System.Reflection.MethodInfo,System.Int32,System.Type)">
            <summary>
            Helps match parameters when searching a method when the parameter is a generic type.
            </summary>
        </member>
        <member name="M:MessagePack.Internal.ObjectSerializationInfo.IsOptimizeTargetType(System.Type)">
            <devremarks>
            Keep this list in sync with ShouldUseFormatterResolverHelper.PrimitiveTypes.
            </devremarks>
        </member>
        <member name="P:MessagePack.Internal.ObjectSerializationInfo.EmittableMember.IsInitOnly">
            <summary>
            Gets a value indicating whether the property can only be set by an object initializer, a constructor, or another `init` member.
            </summary>
        </member>
        <member name="P:MessagePack.Internal.ObjectSerializationInfo.EmittableMember.IsExplicitContract">
            <summary>
            Gets or sets a value indicating whether this member is explicitly opted in with an attribute.
            </summary>
        </member>
        <member name="P:MessagePack.Internal.ObjectSerializationInfo.EmittableMember.IsActuallyWritable">
            <summary>
            Gets a value indicating whether a dynamic resolver can write to this property,
            going beyond <see cref="P:MessagePack.Internal.ObjectSerializationInfo.EmittableMember.IsWritable"/> by also considering CLR bugs.
            </summary>
        </member>
        <member name="P:MessagePack.Internal.ObjectSerializationInfo.EmittableMember.IsProblematicInitProperty">
            <summary>
            Gets a value indicating whether this member is a property with an <see langword="init" /> property setter
            and is declared on a generic class.
            </summary>
            <remarks>
            <see href="https://github.com/neuecc/MessagePack-CSharp/issues/1134">A bug</see> in <see cref="T:System.Reflection.Emit.MethodBuilder"/>
            blocks its ability to invoke property init accessors when in a generic class.
            </remarks>
        </member>
        <member name="T:MessagePack.Internal.InitAccessorInGenericClassNotSupportedException">
            <summary>
            Identifies the unsupported scenario of <see href="https://github.com/neuecc/MessagePack-CSharp/issues/1134">an
            <see langword="init"/> property accessor within a generic class</see>.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackReader">
            <summary>
            A primitive types reader for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when reading methods fail due to invalid data.</exception>
            <exception cref="T:System.IO.EndOfStreamException">Thrown by reading methods when there are not enough bytes to read the required value.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadByte">
            <summary>
            Reads an <see cref="T:System.Byte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt16">
            <summary>
            Reads an <see cref="T:System.UInt16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt32">
            <summary>
            Reads an <see cref="T:System.UInt32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadUInt64">
            <summary>
            Reads an <see cref="T:System.UInt64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSByte">
            <summary>
            Reads an <see cref="T:System.SByte"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt16">
            <summary>
            Reads an <see cref="T:System.Int16"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt32">
            <summary>
            Reads an <see cref="T:System.Int32"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadInt64">
            <summary>
            Reads an <see cref="T:System.Int64"/> value from:
            Some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            Some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>,
            or any of the other MsgPack integer types.
            </summary>
            <returns>The value.</returns>
            <exception cref="T:System.OverflowException">Thrown when the value exceeds what can be stored in the returned type.</exception>
        </member>
        <member name="F:MessagePack.MessagePackReader.reader">
            <summary>
            The reader over the sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.ReadOnlyMemory{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="memory">The buffer to read from.</param>
        </member>
        <member name="M:MessagePack.MessagePackReader.#ctor(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
        </member>
        <member name="P:MessagePack.MessagePackReader.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this deserialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Depth">
            <summary>
            Gets or sets the present depth of the object graph being deserialized.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Sequence">
            <summary>
            Gets the <see cref="T:System.Buffers.ReadOnlySequence`1"/> originally supplied to the constructor.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Position">
            <summary>
            Gets the current position of the reader within <see cref="P:MessagePack.MessagePackReader.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.Consumed">
            <summary>
            Gets the number of bytes consumed by the reader.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.End">
            <summary>
            Gets a value indicating whether the reader is at the end of the sequence.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.IsNil">
            <summary>
            Gets a value indicating whether the reader position is pointing at a nil value.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextMessagePackType">
            <summary>
            Gets the next message pack type to be read.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackReader.NextCode">
            <summary>
            Gets the type of the next MessagePack block.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
            <remarks>
            See <see cref="T:MessagePack.MessagePackCode"/> for valid message pack codes and ranges.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Clone(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackReader"/> struct,
            with the same settings as this one, but with its own buffer to read from.
            </summary>
            <param name="readOnlySequence">The sequence to read from.</param>
            <returns>The new reader.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.CreatePeekReader">
            <summary>
            Creates a new <see cref="T:MessagePack.MessagePackReader"/> at this reader's current position.
            The two readers may then be used independently without impacting each other.
            </summary>
            <returns>A new <see cref="T:MessagePack.MessagePackReader"/>.</returns>
            <devremarks>
            Since this is a struct, copying it completely is as simple as returning itself
            from a property that isn't a "ref return" property.
            </devremarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.Skip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.TrySkip">
            <summary>
            Advances the reader to the next MessagePack primitive to be read.
            </summary>
            <returns><see langword="true"/> if the entire structure beginning at the current <see cref="P:MessagePack.MessagePackReader.Position"/> is found in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>; <see langword="false"/> otherwise.</returns>
            <remarks>
            The entire primitive is skipped, including content of maps or arrays, or any other type with payloads.
            To get the raw MessagePack sequence that was skipped, use <see cref="M:MessagePack.MessagePackReader.ReadRaw"/> instead.
            WARNING: when false is returned, the position of the reader is undefined.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadNil">
            <summary>
            Reads a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
            <returns>A nil value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadNil">
            <summary>
            Reads nil if it is the next token.
            </summary>
            <returns><see langword="true"/> if the next token was nil; <see langword="false"/> otherwise.</returns>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if the end of the sequence provided to the constructor is reached before the expected end of the data.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw(System.Int64)">
            <summary>
            Reads a sequence of bytes without any decoding.
            </summary>
            <param name="length">The number of bytes to read.</param>
            <returns>The sequence of bytes read.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadRaw">
            <summary>
            Reads the next MessagePack primitive.
            </summary>
            <returns>The raw MessagePack sequence.</returns>
            <remarks>
            The entire primitive is read, including content of maps or arrays, or any other type with payloads.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadArrayHeader">
            <summary>
            Read an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>.
            </summary>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadArrayHeader(System.Int32@)">
            <summary>
            Reads an array header from
            <see cref="F:MessagePack.MessagePackCode.Array16"/>,
            <see cref="F:MessagePack.MessagePackCode.Array32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixArray"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixArray"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of elements in the array if the entire array header could be read.</param>
            <returns><see langword="true"/> if there was sufficient buffer and an array header was found; <see langword="false"/> if the buffer incompletely describes an array header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an array header is encountered.</exception>
            <remarks>
            When this method returns <see langword="false"/> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadMapHeader">
            <summary>
            Read a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>.
            </summary>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the elements the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadMapHeader(System.Int32@)">
            <summary>
            Reads a map header from
            <see cref="F:MessagePack.MessagePackCode.Map16"/>,
            <see cref="F:MessagePack.MessagePackCode.Map32"/>, or
            some built-in code between <see cref="F:MessagePack.MessagePackCode.MinFixMap"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixMap"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="count">Receives the number of key=value pairs in the map if the entire map header can be read.</param>
            <returns><see langword="true"/> if there was sufficient buffer and a map header was found; <see langword="false"/> if the buffer incompletely describes an map header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an map header is encountered.</exception>
            <remarks>
            When this method returns <see langword="false"/> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBoolean">
            <summary>
            Reads a boolean value from either a <see cref="F:MessagePack.MessagePackCode.False"/> or <see cref="F:MessagePack.MessagePackCode.True"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadChar">
            <summary>
            Reads a <see cref="T:System.Char"/> from any of:
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            or anything between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>A character.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadSingle">
            <summary>
            Reads an <see cref="T:System.Single"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDouble">
            <summary>
            Reads an <see cref="T:System.Double"/> value from any value encoded with:
            <see cref="F:MessagePack.MessagePackCode.Float64"/>,
            <see cref="F:MessagePack.MessagePackCode.Float32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinNegativeFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxNegativeFixInt"/>,
            or some value between <see cref="F:MessagePack.MessagePackCode.MinFixInt"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixInt"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadDateTime(MessagePack.ExtensionHeader)">
            <summary>
            Reads a <see cref="T:System.DateTime"/> from a value encoded with
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>.
            Expects extension type code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="header">The extension header that was already read.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadBytes">
            <summary>
            Reads a span of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or to support OldSpec compatibility:
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or something between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            A sequence of bytes, or <see langword="null"/> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSequence">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>
            The sequence of bytes, or <see langword="null"/> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadStringSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Reads a string of bytes, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <param name="span">Receives the span to the string.</param>
            <returns>
            <see langword="true"/> if the string is contiguous in memory such that it could be set as a single span.
            <see langword="false"/> if the read token is <see cref="F:MessagePack.MessagePackCode.Nil"/> or the string is not in a contiguous span.
            </returns>
            <remarks>
            Callers should generally be prepared for a <see langword="false"/> result and failover to calling <see cref="M:MessagePack.MessagePackReader.ReadStringSequence"/>
            which can represent a <see langword="null"/> result and handle strings that are not contiguous in memory.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadString">
            <summary>
            Reads a string, whose length is determined by a header of one of these types:
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or a code between <see cref="F:MessagePack.MessagePackCode.MinFixStr"/> and <see cref="F:MessagePack.MessagePackCode.MaxFixStr"/>.
            </summary>
            <returns>A string, or <see langword="null"/> if the current msgpack token is <see cref="F:MessagePack.MessagePackCode.Nil"/>.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormatHeader">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>The extension header.</returns>
            <exception cref="T:System.IO.EndOfStreamException">
            Thrown if the header cannot be read in the bytes left in the <see cref="P:MessagePack.MessagePackReader.Sequence"/>
            or if it is clear that there are insufficient bytes remaining after the header to include all the bytes the header claims to be there.
            </exception>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryReadExtensionFormatHeader(MessagePack.ExtensionHeader@)">
            <summary>
            Reads an extension format header, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>
            if there is sufficient buffer to read it.
            </summary>
            <param name="extensionHeader">Receives the extension header if the remaining bytes in the <see cref="P:MessagePack.MessagePackReader.Sequence"/> fully describe the header.</param>
            <returns>The number of key=value pairs in the map.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if a code other than an extension format header is encountered.</exception>
            <remarks>
            When this method returns <see langword="false"/> the position of the reader is left in an undefined position.
            The caller is expected to recreate the reader (presumably with a longer sequence to read from) before continuing.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadExtensionFormat">
            <summary>
            Reads an extension format header and data, based on one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <returns>
            The extension format.
            The data is a slice from the original sequence passed to this reader's constructor.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowNotEnoughBytesException(System.Exception)">
            <summary>
            Throws an exception indicating that there aren't enough bytes remaining in the buffer to store
            the promised data.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInvalidCode(System.Byte)">
            <summary>
            Throws an <see cref="T:MessagePack.MessagePackSerializationException"/> explaining an unexpected code was encountered.
            </summary>
            <param name="code">The code that was encountered.</param>
            <returns>Nothing. This method always throws.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ThrowInsufficientBufferUnless(System.Boolean)">
            <summary>
            Throws <see cref="T:System.IO.EndOfStreamException"/> if a condition is false.
            </summary>
            <param name="condition">A boolean value.</param>
            <exception cref="T:System.IO.EndOfStreamException">Thrown if <paramref name="condition"/> is <see langword="false"/>.</exception>
        </member>
        <member name="M:MessagePack.MessagePackReader.TryGetStringLengthInBytes(System.Int32@)">
            <summary>
            Gets the length of the next string.
            </summary>
            <param name="length">Receives the length of the next string, if there were enough bytes to read it.</param>
            <returns><see langword="true"/> if there were enough bytes to read the length of the next string; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.GetStringLengthInBytes">
            <summary>
            Gets the length of the next string.
            </summary>
            <returns>The length of the next string.</returns>
        </member>
        <member name="M:MessagePack.MessagePackReader.ReadStringSlow(System.Int32)">
            <summary>
            Reads a string assuming that it is spread across multiple spans in the <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="byteLength">The length of the string to be decoded, in bytes.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="T:MessagePack.MessagePackSerializer">
            <summary>
            High-Level API of MessagePack for C#.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackSerializer.Typeless">
            <summary>
            A convenience wrapper around <see cref="T:MessagePack.MessagePackSerializer"/> that assumes all generic type arguments are <see cref="T:System.Object"/>
            causing the type of top-level objects to be recorded in the MessagePack stream and thus deserialized to the original type automatically.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackSerializer.Typeless.DefaultOptions">
            <summary>
            Gets or sets the default set of options to use when not explicitly specified for a method call.
            </summary>
            <value>The default value is <see cref="F:MessagePack.Resolvers.TypelessContractlessStandardResolver.Options"/>.</value>
            <remarks>
            This is an AppDomain or process-wide setting.
            If you're writing a library, you should NOT set or rely on this property but should instead pass
            in <see cref="P:MessagePack.MessagePackSerializerOptions.Standard"/> (or the required options) explicitly to every method call
            to guarantee appropriate behavior in any application.
            If you are an app author, realize that setting this property impacts the entire application so it should only be
            set once, and before any use of <see cref="T:MessagePack.MessagePackSerializer"/> occurs.
            </remarks>
        </member>
        <member name="P:MessagePack.MessagePackSerializer.DefaultOptions">
            <summary>
            Gets or sets the default set of options to use when not explicitly specified for a method call.
            </summary>
            <value>The default value is <see cref="P:MessagePack.MessagePackSerializerOptions.Standard"/>.</value>
            <remarks>
            This is an AppDomain or process-wide setting.
            If you're writing a library, you should NOT set or rely on this property but should instead pass
            in <see cref="P:MessagePack.MessagePackSerializerOptions.Standard"/> (or the required options) explicitly to every method call
            to guarantee appropriate behavior in any application.
            If you are an app author, realize that setting this property impacts the entire application so it should only be
            set once, and before any use of <see cref="T:MessagePack.MessagePackSerializer"/> occurs.
            </remarks>
        </member>
        <member name="F:MessagePack.MessagePackSerializer.scratchArray">
            <summary>
            A thread-local, recyclable array that may be used for short bursts of code.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize``1(System.Buffers.IBufferWriter{System.Byte},``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serializes a given value with the specified buffer writer.
            </summary>
            <param name="writer">The buffer writer to serialize with.</param>
            <param name="value">The value to serialize.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize``1(MessagePack.MessagePackWriter@,``0,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Serializes a given value with the specified buffer writer.
            </summary>
            <param name="writer">The buffer writer to serialize with.</param>
            <param name="value">The value to serialize.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize``1(``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serializes a given value with the specified buffer writer.
            </summary>
            <param name="value">The value to serialize.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A byte array with the serialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize``1(System.IO.Stream,``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serializes a given value to the specified stream.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="value">The value to serialize.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.SerializeAsync``1(System.IO.Stream,``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serializes a given value to the specified stream.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="value">The value to serialize.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A task that completes with the result of the async serialization operation.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during serialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize``1(System.Buffers.ReadOnlySequence{System.Byte}@,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserializes a value of a given type from a sequence of bytes.
            </summary>
            <typeparam name="T">The type of value to deserialize.</typeparam>
            <param name="byteSequence">The sequence to deserialize from.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize``1(MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Deserializes a value of a given type from a sequence of bytes.
            </summary>
            <typeparam name="T">The type of value to deserialize.</typeparam>
            <param name="reader">The reader to deserialize from.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize``1(System.ReadOnlyMemory{System.Byte},MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserializes a value of a given type from a sequence of bytes.
            </summary>
            <typeparam name="T">The type of value to deserialize.</typeparam>
            <param name="buffer">The buffer to deserialize from.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize``1(System.ReadOnlyMemory{System.Byte},System.Int32@,System.Threading.CancellationToken)">
            <summary>
            Deserializes a value of a given type from a sequence of bytes.
            </summary>
            <typeparam name="T">The type of value to deserialize.</typeparam>
            <param name="buffer">The memory to deserialize from.</param>
            <param name="bytesRead">The number of bytes read.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize``1(System.ReadOnlyMemory{System.Byte},MessagePack.MessagePackSerializerOptions,System.Int32@,System.Threading.CancellationToken)">
            <summary>
            Deserializes a value of a given type from a sequence of bytes.
            </summary>
            <typeparam name="T">The type of value to deserialize.</typeparam>
            <param name="buffer">The memory to deserialize from.</param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="bytesRead">The number of bytes read.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize``1(System.IO.Stream,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserializes the entire content of a <see cref="T:System.IO.Stream"/>.
            </summary>
            <typeparam name="T">The type of value to deserialize.</typeparam>
            <param name="stream">
            The stream to deserialize from.
            The entire stream will be read, and the first msgpack token deserialized will be returned.
            If <see cref="P:System.IO.Stream.CanSeek"/> is true on the stream, its position will be set to just after the last deserialized byte.
            </param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
            <remarks>
            If multiple top-level msgpack data structures are expected on the stream, use <see cref="T:MessagePack.MessagePackStreamReader"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.DeserializeAsync``1(System.IO.Stream,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Deserializes the entire content of a <see cref="T:System.IO.Stream"/>.
            </summary>
            <typeparam name="T">The type of value to deserialize.</typeparam>
            <param name="stream">
            The stream to deserialize from.
            The entire stream will be read, and the first msgpack token deserialized will be returned.
            If <see cref="P:System.IO.Stream.CanSeek"/> is true on the stream, its position will be set to just after the last deserialized byte.
            </param>
            <param name="options">The options. Use <see langword="null"/> to use default options.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The deserialized value.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown when any error occurs during deserialization.</exception>
            <remarks>
            If multiple top-level msgpack data structures are expected on the stream, use <see cref="T:MessagePack.MessagePackStreamReader"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.LZ4Operation(System.Buffers.ReadOnlySequence{System.Byte}@,System.Span{System.Byte},MessagePack.MessagePackSerializer.LZ4Transform)">
            <summary>
            Performs LZ4 compression or decompression.
            </summary>
            <param name="input">The input for the operation.</param>
            <param name="output">The buffer to write the result of the operation.</param>
            <param name="lz4Operation">The LZ4 codec transformation.</param>
            <returns>The number of bytes written to the <paramref name="output"/>.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.SerializeToJson``1(System.IO.TextWriter,``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serialize an object to JSON string.
            </summary>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if an error occurs during serialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.SerializeToJson``1(``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Serialize an object to JSON string.
            </summary>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if an error occurs during serialization.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.ConvertToJson(System.ReadOnlyMemory{System.Byte},MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Convert a message-pack binary to a JSON string.
            </summary>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if an error occurs while reading the messagepack data or writing out the JSON.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.ConvertToJson(System.Buffers.ReadOnlySequence{System.Byte}@,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Convert a message-pack binary to a JSON string.
            </summary>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if an error occurs while reading the messagepack data or writing out the JSON.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.ConvertToJson(MessagePack.MessagePackReader@,System.IO.TextWriter,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Convert a message-pack binary to a JSON string.
            </summary>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if an error occurs while reading the messagepack data or writing out the JSON.</exception>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.ConvertFromJson(System.String,MessagePack.MessagePackWriter@,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Translates the given JSON to MessagePack.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.ConvertFromJson(System.String,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Translates the given JSON to MessagePack.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.ConvertFromJson(System.IO.TextReader,MessagePack.MessagePackWriter@,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Translates the given JSON to MessagePack.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize(System.Type,MessagePack.MessagePackWriter@,System.Object,MessagePack.MessagePackSerializerOptions)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Serialize``1(MessagePack.MessagePackWriter@,``0,MessagePack.MessagePackSerializerOptions)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize(System.Type,System.Buffers.IBufferWriter{System.Byte},System.Object,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Serialize``1(System.Buffers.IBufferWriter{System.Byte},``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize(System.Type,System.Object,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Serialize``1(``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Serialize(System.Type,System.IO.Stream,System.Object,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Serialize``1(System.IO.Stream,``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.SerializeAsync(System.Type,System.IO.Stream,System.Object,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.SerializeAsync``1(System.IO.Stream,``0,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize(System.Type,MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Deserialize``1(MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize(System.Type,System.IO.Stream,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Deserialize``1(System.IO.Stream,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.DeserializeAsync(System.Type,System.IO.Stream,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.DeserializeAsync``1(System.IO.Stream,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize(System.Type,System.ReadOnlyMemory{System.Byte},MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Deserialize``1(System.ReadOnlyMemory{System.Byte},MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.Deserialize(System.Type,System.Buffers.ReadOnlySequence{System.Byte},MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)">
            <seealso cref="M:MessagePack.MessagePackSerializer.Deserialize``1(System.Buffers.ReadOnlySequence{System.Byte}@,MessagePack.MessagePackSerializerOptions,System.Threading.CancellationToken)"/>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.SerializeSemiGeneric``1(MessagePack.MessagePackWriter@,System.Object,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Helper method used by reflection.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializer.DeserializeSemiGeneric``1(MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)">
            <summary>
            Helper method used by reflection.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackStreamReader">
            <summary>
            Reads one or more messagepack data structures from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <remarks>
            This class is *not* thread-safe. Do not call more than one member at once and be sure any call completes (including asynchronous tasks)
            before calling the next one.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.ReadArrayHeaderAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the next messagepack array header.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task whose result is the length of the next array from the stream.
            </returns>
            <remarks>
            Any extra bytes read (between the last complete message and the end of the stream) will be available via the <see cref="P:MessagePack.MessagePackStreamReader.RemainingBytes"/> property.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.ReadArrayAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the next messagepack array and produces each element individually.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task whose result is the next whole data structure from the stream, or <see langword="null"/> if the stream ends.
            The returned sequence is valid until this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed or
            until this method is called again, whichever comes first.
            </returns>
            <remarks>
            When <see langword="null"/> is the result of the returned task,
            any extra bytes read (between the last complete message and the end of the stream) will be available via the <see cref="P:MessagePack.MessagePackStreamReader.RemainingBytes"/> property.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.TryReadArrayHeader(System.Int32@)">
            <summary>
            Reads an array header from <see cref="P:MessagePack.MessagePackStreamReader.ReadData"/> if there are enough bytes to do so.
            </summary>
            <param name="length">Receives the length of the array, if its header could be read.</param>
            <returns><see langword="true"/> if the array header was found and complete; <see langword="false"/> if there were insufficient bytes to read the header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if the next msgpack structure is not an array header.</exception>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.ReadMapHeaderAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the next messagepack map header.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task whose result is the size of the next map from the stream.
            </returns>
            <remarks>
            Any extra bytes read (between the last complete message and the end of the stream) will be available via the <see cref="P:MessagePack.MessagePackStreamReader.RemainingBytes"/> property.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.TryReadMapHeader(System.Int32@)">
            <summary>
            Reads a map header from <see cref="P:MessagePack.MessagePackStreamReader.ReadData"/> if there are enough bytes to do so.
            </summary>
            <param name="count">Receives the size of the map, if its header could be read.</param>
            <returns><see langword="true"/> if the map header was found and complete; <see langword="false"/> if there were insufficient bytes to read the header.</returns>
            <exception cref="T:MessagePack.MessagePackSerializationException">Thrown if the next msgpack structure is not a map header.</exception>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackStreamReader"/> class.
            </summary>
            <param name="stream">The stream to read from. This stream will be disposed of when this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed.</param>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackStreamReader"/> class.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="leaveOpen">If true, leaves the stream open after this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed; otherwise, false.</param>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.#ctor(System.IO.Stream,System.Boolean,MessagePack.SequencePool)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackStreamReader"/> class.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="leaveOpen">If true, leaves the stream open after this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed; otherwise, false.</param>
            <param name="sequencePool">The pool to rent a <see cref="T:Nerdbank.Streams.Sequence`1"/> object from.</param>
        </member>
        <member name="P:MessagePack.MessagePackStreamReader.RemainingBytes">
            <summary>
            Gets any bytes that have been read since the last complete message returned from <see cref="M:MessagePack.MessagePackStreamReader.ReadAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackStreamReader.ReadData">
            <summary>
            Gets the sequence that we read data from the <see cref="F:MessagePack.MessagePackStreamReader.stream"/> into.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the next whole (top-level) messagepack data structure.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>
            A task whose result is the next whole data structure from the stream, or <see langword="null"/> if the stream ends.
            The returned sequence is valid until this <see cref="T:MessagePack.MessagePackStreamReader"/> is disposed or
            until this method is called again, whichever comes first.
            </returns>
            <remarks>
            When <see langword="null"/> is the result of the returned task,
            any extra bytes read (between the last complete message and the end of the stream) will be available via the <see cref="P:MessagePack.MessagePackStreamReader.RemainingBytes"/> property.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.DiscardBufferedData">
            <summary>
            Arranges for the next read operation to start by reading from the underlying <see cref="T:System.IO.Stream"/>
            instead of any data buffered from a previous read.
            </summary>
            <remarks>
            This is appropriate if the underlying <see cref="T:System.IO.Stream"/> has been repositioned such that
            any previously buffered data is no longer applicable to what the caller wants to read.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.Dispose(System.Boolean)">
            <summary>
            Disposes of managed and unmanaged resources.
            </summary>
            <param name="disposing"><see langword="true"/> if this instance is being disposed; <see langword="false"/> if it is being finalized.</param>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.RecycleLastMessage">
            <summary>
            Recycle memory from a previously returned message.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.TryReadMoreDataAsync(System.Threading.CancellationToken)">
            <summary>
            Read more data from the stream into the <see cref="P:MessagePack.MessagePackStreamReader.ReadData"/> buffer.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns><see langword="true"/> if more data was read; <see langword="false"/> if the end of the stream had already been reached.</returns>
        </member>
        <member name="M:MessagePack.MessagePackStreamReader.TryReadNextMessage(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Checks whether the content in <see cref="P:MessagePack.MessagePackStreamReader.ReadData"/> include a complete messagepack structure.
            </summary>
            <param name="completeMessage">Receives the sequence of the first complete data structure found, if any.</param>
            <returns><see langword="true"/> if a complete data structure was found; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:MessagePack.BufferWriter">
            <summary>
            A fast access struct that wraps <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._output">
            <summary>
            The underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._span">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            Backing field for the <see cref="P:MessagePack.BufferWriter.Span"/> property.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._segment">
            <summary>
            The result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetMemory(System.Int32)"/>, less any bytes already "consumed" with <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._buffered">
            <summary>
            The number of uncommitted bytes (all the calls to <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> since the last call to <see cref="M:MessagePack.BufferWriter.Commit"/>).
            </summary>
        </member>
        <member name="F:MessagePack.BufferWriter._bytesCommitted">
            <summary>
            The total number of bytes written with this writer.
            Backing field for the <see cref="P:MessagePack.BufferWriter.BytesCommitted"/> property.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="output">The <see cref="T:System.Buffers.IBufferWriter`1"/> to be wrapped.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.BufferWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.BufferWriter.Span">
            <summary>
            Gets the result of the last call to <see cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.BytesCommitted">
            <summary>
            Gets the total number of bytes written with this writer.
            </summary>
        </member>
        <member name="P:MessagePack.BufferWriter.UnderlyingWriter">
            <summary>
            Gets the <see cref="T:System.Buffers.IBufferWriter`1"/> underlying this instance.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Commit">
            <summary>
            Calls <see cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/> on the underlying writer
            with the number of uncommitted bytes.
            </summary>
        </member>
        <member name="M:MessagePack.BufferWriter.Advance(System.Int32)">
            <summary>
            Used to indicate that part of the buffer has been written to.
            </summary>
            <param name="count">The number of bytes written to.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer and calls <see cref="M:MessagePack.BufferWriter.Advance(System.Int32)"/> with the length of the source buffer.
            </summary>
            <param name="source">The buffer to copy in.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.Ensure(System.Int32)">
            <summary>
            Acquires a new buffer if necessary to ensure that some given number of bytes can be written to a single buffer.
            </summary>
            <param name="count">The number of bytes that must be allocated in a single buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.TryGetUncommittedSpan(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Gets the span to the bytes written if they were never committed to the underlying buffer writer.
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:MessagePack.BufferWriter.EnsureMore(System.Int32)">
            <summary>
            Gets a fresh span to write to, with an optional minimum size.
            </summary>
            <param name="count">The minimum size for the next requested buffer.</param>
        </member>
        <member name="M:MessagePack.BufferWriter.WriteMultiBuffer(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies the caller's buffer into this writer, potentially across multiple buffers from the underlying writer.
            </summary>
            <param name="source">The buffer to copy into this writer.</param>
        </member>
        <member name="T:MessagePack.IFormatterResolver">
            <summary>
            Allows querying for a formatter for serializing or deserializing a particular <see cref="T:System.Type" />.
            </summary>
        </member>
        <member name="M:MessagePack.IFormatterResolver.GetFormatter``1">
            <summary>
            Gets an <see cref="T:MessagePack.Formatters.IMessagePackFormatter`1"/> instance that can serialize or deserialize some type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of value to be serialized or deserialized.</typeparam>
            <returns>A formatter, if this resolver supplies one for type <typeparamref name="T"/>; otherwise <see langword="null"/>.</returns>
        </member>
        <member name="T:MessagePack.LZ4.LZ4Codec">
            <summary>Unsafe LZ4 codec.</summary>
        </member>
        <member name="F:MessagePack.LZ4.LZ4Codec.MEMORY_USAGE">
            <summary>
            Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
            Increasing memory usage improves compression ratio
            Reduced memory usage can improve speed, due to cache effect
            Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache.
            </summary>
        </member>
        <member name="F:MessagePack.LZ4.LZ4Codec.NOTCOMPRESSIBLE_DETECTIONLEVEL">
            <summary>
            Decreasing this value will make the algorithm skip faster data segments considered "incompressible"
            This may decrease compression ratio dramatically, but will be faster on incompressible data
            Increasing this value will make the algorithm search more before declaring a segment "incompressible"
            This could improve compression a bit, but will be slower on incompressible data
            The default value (6) is recommended.
            </summary>
        </member>
        <member name="M:MessagePack.LZ4.LZ4Codec.MaximumOutputLength(System.Int32)">
            <summary>Gets maximum the length of the output.</summary>
            <param name="inputLength">Length of the input.</param>
            <returns>Maximum number of bytes needed for compressed buffer.</returns>
        </member>
        <member name="M:MessagePack.LZ4.LZ4Codec.Encode(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>Encodes the specified input.</summary>
            <param name="input">The input.</param>
            <param name="output">The output.</param>
            <returns>Number of bytes written.</returns>
        </member>
        <member name="M:MessagePack.LZ4.LZ4Codec.Decode(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>Decodes the specified input.</summary>
            <param name="input">The input.</param>
            <param name="output">The output.</param>
            <returns>Number of bytes written.</returns>
        </member>
        <member name="M:MessagePack.LZ4.LZ4Codec.BlockCopy32(System.Byte*,System.Byte*,System.Int32)">
            <summary>Copies block of memory.</summary>
            <param name="src">The source.</param>
            <param name="dst">The destination.</param>
            <param name="len">The length (in bytes).</param>
        </member>
        <member name="M:MessagePack.LZ4.LZ4Codec.BlockCopy64(System.Byte*,System.Byte*,System.Int32)">
            <summary>Copies block of memory.</summary>
            <param name="src">The source.</param>
            <param name="dst">The destination.</param>
            <param name="len">The length (in bytes).</param>
        </member>
        <member name="T:MessagePack.MessagePackType">
            <summary>
            https://github.com/msgpack/msgpack/blob/master/spec.md#serialization-type-to-format-conversion.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackCode">
            <summary>
            The core type codes as defined by msgpack.
            </summary>
            <seealso href="https://github.com/msgpack/msgpack/blob/master/spec.md#overview" />
        </member>
        <member name="M:MessagePack.MessagePackCode.IsSignedInteger(System.Byte)">
            <summary>
            Checks whether a given messagepack code represents an integer that might include a sign (i.e. might be a negative number).
            </summary>
            <param name="code">The messagepack code.</param>
            <returns>A boolean value.</returns>
        </member>
        <member name="T:MessagePack.ReservedMessagePackExtensionTypeCode">
            <summary>
            The officially defined messagepack extension type codes.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackCompression">
            <summary>
            Identifies the various compression schemes which might be applied at the msgpack level.
            </summary>
        </member>
        <member name="F:MessagePack.MessagePackCompression.None">
            <summary>
            No compression is applied at the msgpack level.
            </summary>
        </member>
        <member name="F:MessagePack.MessagePackCompression.Lz4Block">
            <summary>
            Compresses an entire msgpack sequence as a single lz4 block format.
            This is the simple compression that achieves best compression ratio,
            at the cost of copying the entire sequence when necessary to get contiguous memory.
            </summary>
            <remarks>
            Uses msgpack type code ext99 and is compatible with v1 of this library.
            </remarks>
            <devremarks>
            See also ThisLibraryExtensionTypeCodes.Lz4Block.
            </devremarks>
        </member>
        <member name="F:MessagePack.MessagePackCompression.Lz4BlockArray">
            <summary>
            Compresses an entire msgpack sequence as a array of lz4 block format.
            This is compressed/decompressed in chunks that do not consume LOH,
            but the compression ratio is slightly sacrificed.
            </summary>
            <remarks>
            Uses msgpack type code ext98 in array.
            </remarks>
            <devremarks>
            See also ThisLibraryExtensionTypeCodes.Lz4BlockArray.
            </devremarks>
        </member>
        <member name="T:MessagePack.MessagePackCompressionExtensions">
            <summary>
            Extensions for <see cref="T:MessagePack.MessagePackCompression"/>.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackSecurity">
            <summary>
            Settings related to security, particularly relevant when deserializing data from untrusted sources.
            </summary>
        </member>
        <member name="F:MessagePack.MessagePackSecurity.TrustedData">
            <summary>
            Gets an instance preconfigured with settings that omit all protections. Useful for deserializing fully-trusted and valid msgpack sequences.
            </summary>
        </member>
        <member name="F:MessagePack.MessagePackSecurity.UntrustedData">
            <summary>
            Gets an instance preconfigured with protections applied with reasonable settings for deserializing untrusted msgpack sequences.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.#ctor(MessagePack.MessagePackSecurity)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSecurity"/> class
            with properties copied from a provided template.
            </summary>
            <param name="copyFrom">The template to copy from.</param>
        </member>
        <member name="P:MessagePack.MessagePackSecurity.HashCollisionResistant">
            <summary>
            Gets a value indicating whether data to be deserialized is untrusted and thus should not be allowed to create
            dictionaries or other hash-based collections unless the hashed type has a hash collision resistant implementation available.
            This can mitigate some denial of service attacks when deserializing untrusted code.
            </summary>
            <value>
            The value is <see langword="false"/> for <see cref="F:MessagePack.MessagePackSecurity.TrustedData"/> and <see langword="true"/> for <see cref="F:MessagePack.MessagePackSecurity.UntrustedData"/>.
            </value>
        </member>
        <member name="P:MessagePack.MessagePackSecurity.MaximumObjectGraphDepth">
            <summary>
            Gets the maximum depth of an object graph that may be deserialized.
            </summary>
            <remarks>
            <para>
            This value can be reduced to avoid a stack overflow that would crash the process when deserializing a msgpack sequence designed to cause deep recursion.
            A very short callstack on a thread with 1MB of total stack space might deserialize ~2000 nested arrays before crashing due to a stack overflow.
            Since stack space occupied may vary by the kind of object deserialized, a conservative value for this property to defend against stack overflow attacks might be 500.
            </para>
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.WithMaximumObjectGraphDepth(System.Int32)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSecurity.MaximumObjectGraphDepth"/> property set to a new value.
            </summary>
            <param name="maximumObjectGraphDepth">The new value for the <see cref="P:MessagePack.MessagePackSecurity.MaximumObjectGraphDepth"/> property.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.WithHashCollisionResistant(System.Boolean)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSecurity.HashCollisionResistant"/> property set to a new value.
            </summary>
            <param name="hashCollisionResistant">The new value for the <see cref="P:MessagePack.MessagePackSecurity.HashCollisionResistant"/> property.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.GetEqualityComparer``1">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> that is suitable to use with a hash-based collection.
            </summary>
            <typeparam name="T">The type of key that will be hashed in the collection.</typeparam>
            <returns>The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to use.</returns>
            <remarks>
            When <see cref="P:MessagePack.MessagePackSecurity.HashCollisionResistant"/> is active, this will be a collision resistant instance which may reject certain key types.
            When <see cref="P:MessagePack.MessagePackSecurity.HashCollisionResistant"/> is not active, this will be <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.GetEqualityComparer">
            <summary>
            Gets an <see cref="T:System.Collections.IEqualityComparer"/> that is suitable to use with a hash-based collection.
            </summary>
            <returns>The <see cref="T:System.Collections.IEqualityComparer"/> to use.</returns>
            <remarks>
            When <see cref="P:MessagePack.MessagePackSecurity.HashCollisionResistant"/> is active, this will be a collision resistant instance which may reject certain key types.
            When <see cref="P:MessagePack.MessagePackSecurity.HashCollisionResistant"/> is not active, this will be <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.GetHashCollisionResistantEqualityComparer``1">
            <summary>
            Returns a hash collision resistant equality comparer.
            </summary>
            <typeparam name="T">The type of key that will be hashed in the collection.</typeparam>
            <returns>A hash collision resistant equality comparer.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.DepthStep(MessagePack.MessagePackReader@)">
            <summary>
            Checks the depth of the deserializing graph and increments it by 1.
            </summary>
            <param name="reader">The reader that is involved in deserialization.</param>
            <remarks>
            Callers should decrement <see cref="P:MessagePack.MessagePackReader.Depth"/> after exiting that edge in the graph.
            </remarks>
            <exception cref="T:System.InsufficientExecutionStackException">Thrown if <see cref="P:MessagePack.MessagePackReader.Depth"/> is already at or exceeds <see cref="P:MessagePack.MessagePackSecurity.MaximumObjectGraphDepth"/>.</exception>
            <remarks>
            Rather than wrap the body of every <see cref="M:MessagePack.Formatters.IMessagePackFormatter`1.Deserialize(MessagePack.MessagePackReader@,MessagePack.MessagePackSerializerOptions)"/> method,
            this should wrap *calls* to these methods. They need not appear in pure "thunk" methods that simply delegate the deserialization to another formatter.
            In this way, we can avoid repeatedly incrementing and decrementing the counter when deserializing each element of a collection.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.GetHashCollisionResistantEqualityComparer">
            <summary>
            Returns a hash collision resistant equality comparer.
            </summary>
            <returns>A hash collision resistant equality comparer.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSecurity.Clone">
            <summary>
            Creates a new instance that is a copy of this one.
            </summary>
            <remarks>
            Derived types should override this method to instantiate their own derived type.
            </remarks>
        </member>
        <member name="T:MessagePack.MessagePackSecurity.CollisionResistantHasher`1">
            <summary>
            A hash collision resistant implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
            <typeparam name="T">The type of key that will be hashed.</typeparam>
        </member>
        <member name="T:MessagePack.MessagePackSecurity.ObjectFallbackEqualityComparer">
            <summary>
            A special hash-resistent equality comparer that defers picking the actual implementation
            till it can check the runtime type of each value to be hashed.
            </summary>
        </member>
        <member name="T:MessagePack.MessagePackSerializationException">
            <summary>
            An exception thrown during serializing an object graph or deserializing a messagepack sequence.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="message">The exception message.</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:MessagePack.MessagePackSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializationException"/> class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Serialization context.</param>
        </member>
        <member name="T:MessagePack.MessagePackSerializerOptions">
            <summary>
            An immutable description of options for running the <see cref="T:MessagePack.MessagePackSerializer"/>.
            </summary>
        </member>
        <member name="F:MessagePack.MessagePackSerializerOptions.DisallowedTypes">
            <summary>
            A collection of known dangerous types that are not expected in a typical MessagePack stream,
            and thus are rejected by the default implementation of <see cref="M:MessagePack.MessagePackSerializerOptions.ThrowIfDeserializingTypeIsDisallowed(System.Type)"/>.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.Standard">
            <summary>
            Gets a good default set of options that uses the <see cref="T:MessagePack.Resolvers.StandardResolver"/> and no compression.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.#ctor(MessagePack.IFormatterResolver)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializerOptions"/> class.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.#ctor(MessagePack.MessagePackSerializerOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackSerializerOptions"/> class
            with members initialized from an existing instance.
            </summary>
            <param name="copyFrom">The options to copy from.</param>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.Resolver">
            <summary>
            Gets the resolver to use for complex types.
            </summary>
            <value>An instance of <see cref="T:MessagePack.IFormatterResolver"/>. Never <see langword="null"/>.</value>
            <exception cref="T:System.ArgumentNullException">Thrown if an attempt is made to set this property to <see langword="null"/>.</exception>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.Compression">
            <summary>
            Gets the compression scheme to apply to serialized sequences.
            </summary>
            <remarks>
            When set to something other than <see cref="F:MessagePack.MessagePackCompression.None"/>,
            deserialization can still work on uncompressed sequences,
            and serialization may not compress if msgpack sequences are short enough that compression would not likely be advantageous.
            </remarks>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.CompressionMinLength">
            <summary>
            Gets the length a serialized msgpack result must equal or exceed before <see cref="P:MessagePack.MessagePackSerializerOptions.Compression"/> is applied.
            </summary>
            <value>The default value is 64.</value>
            <remarks>
            When compression is <em>not</em> applied due to a short serialized result, deserialization will still succeed
            even if <see cref="P:MessagePack.MessagePackSerializerOptions.Compression"/> is set to something other than <see cref="F:MessagePack.MessagePackCompression.None"/>.
            </remarks>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.SuggestedContiguousMemorySize">
            <summary>
            Gets the size of contiguous memory blocks in bytes that may be allocated for buffering purposes.
            </summary>
            <value>The default value is 1MB.</value>
            <remarks>
            Larger values may perform a bit faster, but may result in adding a runtime perf tax due to using the
            <see href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap">Large Object Heap</see>.
            </remarks>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.OldSpec">
            <summary>
            Gets a value indicating whether to serialize with <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> set to some value
            causing messagepack spec compliance to be explicitly set to the old or new format.
            </summary>
            <value>
            A null value means the <see cref="T:MessagePack.MessagePackWriter"/>'s default or previous setting will be used.
            A non-null value will be applied to the <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> property for the duration of a
            serialization and then reverted to its prior setting.
            </value>
            <remarks>
            Reading always supports both new and old spec.
            </remarks>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.OmitAssemblyVersion">
            <summary>
            Gets a value indicating whether serialization should omit assembly version, culture and public key token metadata when using the typeless formatter.
            </summary>
            <value>The default value is <see langword="false"/>.</value>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.AllowAssemblyVersionMismatch">
            <summary>
            Gets a value indicating whether deserialization may instantiate types from an assembly with a different version if a matching version cannot be found.
            </summary>
            <value>The default value is <see langword="false"/>.</value>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.Security">
            <summary>
            Gets the security-related options for deserializing messagepack sequences.
            </summary>
            <value>
            The default value is to use <see cref="F:MessagePack.MessagePackSecurity.TrustedData"/>.
            </value>
        </member>
        <member name="P:MessagePack.MessagePackSerializerOptions.SequencePool">
            <summary>
            Gets a thread-safe pool of reusable <see cref="T:Nerdbank.Streams.Sequence`1"/> objects.
            </summary>
            <value>The default value is the <see cref="F:MessagePack.SequencePool.Shared"/> instance.</value>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.LoadType(System.String)">
            <summary>
            Gets a type given a string representation of the type.
            </summary>
            <param name="typeName">The name of the type to load. This is typically the <see cref="P:System.Type.AssemblyQualifiedName"/> but may use the assembly's simple name.</param>
            <returns>The loaded type or <see langword="null"/> if no matching type could be found.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.ThrowIfDeserializingTypeIsDisallowed(System.Type)">
            <summary>
            Checks whether a given type may be deserialized.
            </summary>
            <param name="type">The type to be instantiated.</param>
            <exception cref="T:System.TypeAccessException">Thrown if the <paramref name="type"/> is not allowed to be deserialized.</exception>
            <remarks>
            This method provides a means for an important security mitigation when using the Typeless formatter to prevent untrusted messagepack from
            deserializing objects that may be harmful if instantiated, disposed or finalized.
            The default implementation throws for only a few known dangerous types.
            Applications that deserialize from untrusted sources should override this method and throw if the type is not among the expected set.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithResolver(MessagePack.IFormatterResolver)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.Resolver"/> property set to a new value.
            </summary>
            <param name="resolver">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.Resolver"/>.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithCompression(MessagePack.MessagePackCompression)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.Compression"/> property set to a new value.
            </summary>
            <param name="compression">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.Compression"/> property.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithCompressionMinLength(System.Int32)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.CompressionMinLength"/> property set to a new value.
            </summary>
            <param name="compressionMinLength">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.CompressionMinLength"/> property. Must be a positive integer.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithSuggestedContiguousMemorySize(System.Int32)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.SuggestedContiguousMemorySize"/> property set to a new value.
            </summary>
            <param name="suggestedContiguousMemorySize">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.SuggestedContiguousMemorySize"/> property. Must be at least 256.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithOldSpec(System.Nullable{System.Boolean})">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.OldSpec"/> property set to a new value.
            </summary>
            <param name="oldSpec">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.OldSpec"/>.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithOmitAssemblyVersion(System.Boolean)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.OmitAssemblyVersion"/> property set to a new value.
            </summary>
            <param name="omitAssemblyVersion">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.OmitAssemblyVersion"/> property.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithAllowAssemblyVersionMismatch(System.Boolean)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.AllowAssemblyVersionMismatch"/> property set to a new value.
            </summary>
            <param name="allowAssemblyVersionMismatch">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.AllowAssemblyVersionMismatch"/> property.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithSecurity(MessagePack.MessagePackSecurity)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.Security"/> property set to a new value.
            </summary>
            <param name="security">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.Security"/> property.</param>
            <returns>The new instance; or the original if the value is unchanged.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.WithPool(MessagePack.SequencePool)">
            <summary>
            Gets a copy of these options with the <see cref="P:MessagePack.MessagePackSerializerOptions.SequencePool"/> property set to a new value.
            </summary>
            <param name="pool">The new value for the <see cref="P:MessagePack.MessagePackSerializerOptions.SequencePool"/> property.</param>
            <returns>The new instance.</returns>
        </member>
        <member name="M:MessagePack.MessagePackSerializerOptions.Clone">
            <summary>
            Creates a clone of this instance with the same properties set.
            </summary>
            <returns>The cloned instance. Guaranteed to be a new instance.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if this instance is a derived type that doesn't override this method.</exception>
        </member>
        <member name="T:MessagePack.MessagePackWriter">
            <summary>
            A primitive types writer for the MessagePack format.
            </summary>
            <remarks>
            <see href="https://github.com/msgpack/msgpack/blob/master/spec.md">The MessagePack spec.</see>.
            </remarks>
        </member>
        <member name="F:MessagePack.MessagePackWriter.writer">
            <summary>
            The writer to use.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="writer">The writer to use.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.#ctor(MessagePack.SequencePool,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct.
            </summary>
            <param name="sequencePool">The pool from which to draw an <see cref="T:System.Buffers.IBufferWriter`1"/> if required..</param>
            <param name="array">An array to start with so we can avoid accessing the <paramref name="sequencePool"/> if possible.</param>
        </member>
        <member name="P:MessagePack.MessagePackWriter.CancellationToken">
            <summary>
            Gets or sets the cancellation token for this serialization operation.
            </summary>
        </member>
        <member name="P:MessagePack.MessagePackWriter.OldSpec">
            <summary>
            Gets or sets a value indicating whether to write in <see href="https://github.com/msgpack/msgpack/blob/master/spec-old.md">old spec</see> compatibility mode.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Clone(System.Buffers.IBufferWriter{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.MessagePackWriter"/> struct,
            with the same settings as this one, but with its own buffer writer.
            </summary>
            <param name="writer">The writer to use for the new instance.</param>
            <returns>The new writer.</returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Flush">
            <summary>
            Ensures everything previously written has been flushed to the underlying <see cref="T:System.Buffers.IBufferWriter`1"/>.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteNil">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Nil"/> value.
            </summary>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Copies bytes directly into the message pack writer.
            </summary>
            <param name="rawMessagePackBlock">The span of bytes to copy from.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.Int32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteArrayHeader(System.UInt32)">
            <summary>
            Write the length of the next array to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixArray"/>,
            <see cref="F:MessagePack.MessagePackCode.Array16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Array32"/>.
            </summary>
            <param name="count">The number of elements that will be written in the array.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.Int32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteMapHeader(System.UInt32)">
            <summary>
            Write the length of the next map to be written in the most compact form of
            <see cref="F:MessagePack.MessagePackCode.MinFixMap"/>,
            <see cref="F:MessagePack.MessagePackCode.Map16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Map32"/>.
            </summary>
            <param name="count">The number of key=value pairs that will be written in the map.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt8(System.Byte)">
            <summary>
            Writes a <see cref="T:System.Byte"/> value using <see cref="F:MessagePack.MessagePackCode.UInt8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.SByte)">
            <summary>
            Writes an 8-bit value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt8(System.SByte)">
            <summary>
            Writes an 8-bit value using <see cref="F:MessagePack.MessagePackCode.Int8"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a <see cref="T:System.UInt16"/> value using <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>, or
            <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a <see cref="T:System.Int16"/> using <see cref="F:MessagePack.MessagePackCode.Int16"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>, or
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes an <see cref="T:System.UInt32"/> using <see cref="F:MessagePack.MessagePackCode.UInt32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes an <see cref="T:System.UInt64"/> using <see cref="F:MessagePack.MessagePackCode.Int32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Int64)">
            <summary>
            Writes an <see cref="T:System.Int64"/> using a built-in 1-byte code when within specific MessagePack-supported ranges,
            or the most compact of
            <see cref="F:MessagePack.MessagePackCode.UInt8"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt16"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt32"/>,
            <see cref="F:MessagePack.MessagePackCode.UInt64"/>,
            <see cref="F:MessagePack.MessagePackCode.Int8"/>,
            <see cref="F:MessagePack.MessagePackCode.Int16"/>,
            <see cref="F:MessagePack.MessagePackCode.Int32"/>,
            <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> using <see cref="F:MessagePack.MessagePackCode.Int64"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Boolean)">
            <summary>
            Writes a <see cref="T:System.Boolean"/> value using either <see cref="F:MessagePack.MessagePackCode.True"/> or <see cref="F:MessagePack.MessagePackCode.False"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Char)">
            <summary>
            Writes a <see cref="T:System.Char"/> value using a 1-byte code when possible, otherwise as <see cref="F:MessagePack.MessagePackCode.UInt8"/> or <see cref="F:MessagePack.MessagePackCode.UInt16"/>.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Single)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float32"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Double)">
            <summary>
            Writes a <see cref="F:MessagePack.MessagePackCode.Float64"/> value.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.DateTime)">
            <summary>
            Writes a <see cref="T:System.DateTime"/> using the message code <see cref="F:MessagePack.ReservedMessagePackExtensionTypeCode.DateTime"/>.
            </summary>
            <param name="dateTime">The value to write.</param>
            <exception cref="T:System.NotSupportedException">Thrown when <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is true because the old spec does not define a <see cref="T:System.DateTime"/> format.</exception>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Byte[])">
            <summary>
            Writes a <see cref="T:System.Byte"/>[], prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if <paramref name="src"/> is <see langword="null"/>.
            </summary>
            <param name="src">The array of bytes to write. May be <see langword="null"/>.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a span of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <see langword="true"/>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes a sequence of bytes, prefixed with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="src">The span of bytes to write.</param>
            <remarks>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <see langword="true"/>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBinHeader(System.Int32)">
            <summary>
            Writes the header that precedes a raw binary sequence with a length encoded as the smallest fitting from:
            <see cref="F:MessagePack.MessagePackCode.Bin8"/>,
            <see cref="F:MessagePack.MessagePackCode.Bin16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Bin32"/>.
            </summary>
            <param name="length">The length of bytes that will be written next.</param>
            <remarks>
            <para>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.Write(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </para>
            <para>
            When <see cref="P:MessagePack.MessagePackWriter.OldSpec"/> is <see langword="true"/>, the msgpack code used is <see cref="F:MessagePack.MessagePackCode.Str8"/>, <see cref="F:MessagePack.MessagePackCode.Str16"/> or <see cref="F:MessagePack.MessagePackCode.Str32"/> instead.
            </para>
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes out an array of bytes that (may) represent a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="utf8stringBytes">The bytes to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteStringHeader(System.Int32)">
            <summary>
            Writes out the header that may precede a UTF-8 encoded string, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="byteCount">The number of bytes in the string that will follow this header.</param>
            <remarks>
            The caller should use <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.Buffers.ReadOnlySequence{System.Byte}@)"/> or <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            after calling this method to actually write the content.
            Alternatively a single call to <see cref="M:MessagePack.MessagePackWriter.WriteString(System.ReadOnlySpan{System.Byte})"/> or <see cref="M:MessagePack.MessagePackWriter.WriteString(System.Buffers.ReadOnlySequence{System.Byte}@)"/> will take care of the header and content in one call.
            </remarks>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.String)">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>,
            or <see cref="F:MessagePack.MessagePackCode.Nil"/> if the <paramref name="value"/> is <see langword="null"/>.
            </summary>
            <param name="value">The value to write. May be null.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Write(System.ReadOnlySpan{System.Char})">
            <summary>
            Writes out a <see cref="T:System.String"/>, prefixed with the length using one of these message codes:
            <see cref="F:MessagePack.MessagePackCode.MinFixStr"/>,
            <see cref="F:MessagePack.MessagePackCode.Str8"/>,
            <see cref="F:MessagePack.MessagePackCode.Str16"/>,
            <see cref="F:MessagePack.MessagePackCode.Str32"/>.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormatHeader(MessagePack.ExtensionHeader)">
            <summary>
            Writes the extension format header, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionHeader">The extension header.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteExtensionFormat(MessagePack.ExtensionResult)">
            <summary>
            Writes an extension format, using the smallest one of these codes:
            <see cref="F:MessagePack.MessagePackCode.FixExt1"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt2"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt4"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt8"/>,
            <see cref="F:MessagePack.MessagePackCode.FixExt16"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext8"/>,
            <see cref="F:MessagePack.MessagePackCode.Ext16"/>, or
            <see cref="F:MessagePack.MessagePackCode.Ext32"/>.
            </summary>
            <param name="extensionData">The extension data.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)">
            <summary>
            Gets memory where raw messagepack data can be written.
            </summary>
            <param name="length">The size of the memory block required.</param>
            <returns>The span of memory to write to. This *may* exceed <paramref name="length"/>.</returns>
            <remarks>
            <para>After initializing the resulting memory, always follow up with a call to <see cref="M:MessagePack.MessagePackWriter.Advance(System.Int32)"/>.</para>
            <para>
            This is similar in purpose to <see cref="M:MessagePack.MessagePackWriter.WriteRaw(System.ReadOnlySpan{System.Byte})"/>
            but provides uninitialized memory for the caller to write to instead of copying initialized memory from elsewhere.
            </para>
            </remarks>
            <seealso cref="M:System.Buffers.IBufferWriter`1.GetSpan(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.Advance(System.Int32)">
            <summary>
            Commits memory previously returned from <see cref="M:MessagePack.MessagePackWriter.GetSpan(System.Int32)"/> as initialized.
            </summary>
            <param name="length">The number of bytes initialized with messagepack data from the previously returned span.</param>
            <seealso cref="M:System.Buffers.IBufferWriter`1.Advance(System.Int32)"/>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt16)">
            <summary>
            Writes a 16-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt32)">
            <summary>
            Writes a 32-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteBigEndian(System.UInt64)">
            <summary>
            Writes a 64-bit integer in big endian format.
            </summary>
            <param name="value">The integer.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Estimates the length of the header required for a given string.
            </summary>
            <param name="characterLength">The length of the string to be written, in characters.</param>
            <param name="bufferSize">Receives the guaranteed length of the returned buffer.</param>
            <param name="encodedBytesOffset">Receives the offset within the returned buffer to write the encoded string to.</param>
            <returns>
            A reference to the first byte in the buffer.
            </returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.WriteString_PostEncoding(System.Byte*,System.Int32,System.Int32)">
            <summary>
            Finalizes an encoding of a string.
            </summary>
            <param name="pBuffer">A pointer obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="estimatedOffset">The offset obtained from a prior call to <see cref="M:MessagePack.MessagePackWriter.WriteString_PrepareSpan(System.Int32,System.Int32@,System.Int32@)"/>.</param>
            <param name="byteCount">The number of bytes used to actually encode the string.</param>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetEncodedLength(System.Int64)">
            <summary>
            Get the number of bytes required to encode a value in msgpack.
            </summary>
            <param name="value">The value to encode.</param>
            <returns>The byte length; One of 1, 2, 3, 5 or 9 bytes.</returns>
        </member>
        <member name="M:MessagePack.MessagePackWriter.GetEncodedLength(System.UInt64)">
            <summary>
            Get the number of bytes required to encode a value in msgpack.
            </summary>
            <param name="value">The value to encode.</param>
            <returns>The byte length; One of 1, 2, 3, 5 or 9 bytes.</returns>
        </member>
        <member name="T:MessagePack.MonoProtection">
            <summary>
            Special behavior for running on the mono runtime.
            </summary>
        </member>
        <member name="P:MessagePack.MonoProtection.IsRunningOnMono">
            <summary>
            Gets a value indicating whether the mono runtime is executing this code.
            </summary>
        </member>
        <member name="F:MessagePack.MonoProtection.RefEmitLock">
            <summary>
            A lock that we enter on mono when generating dynamic types.
            </summary>
        </member>
        <member name="M:MessagePack.MonoProtection.EnterRefEmitLock">
            <summary>
            The method to call within the expression of a <c>using</c> statement whose block surrounds all Ref.Emit code.
            </summary>
            <returns>The value to be disposed of to exit the Ref.Emit lock.</returns>
            <remarks>
            This is a no-op except when running on Mono.
            <see href="https://github.com/mono/mono/issues/20369#issuecomment-690316456">Mono's implementation of Ref.Emit is not thread-safe</see> so we have to lock around all use of it
            when using that runtime.
            </remarks>
        </member>
        <member name="T:MessagePack.Resolvers.AttributeFormatterResolver">
            <summary>
            Get formatter from <see cref="T:MessagePack.MessagePackFormatterAttribute"/>.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.AttributeFormatterResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.BuiltinResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.CachingFormatterResolver">
            <summary>
            A base class for <see cref="T:MessagePack.IFormatterResolver"/> classes that want to cache their responses for perf reasons.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.CachingFormatterResolver.formatters">
            <summary>
            The cache of types to their formatters.
            </summary>
        </member>
        <member name="M:MessagePack.Resolvers.CachingFormatterResolver.GetFormatter``1">
            <inheritdoc />
        </member>
        <member name="M:MessagePack.Resolvers.CachingFormatterResolver.GetFormatterCore``1">
            <summary>
            Looks up a formatter for a type that has not been previously cached.
            </summary>
            <typeparam name="T">The type to be formatted.</typeparam>
            <returns>The formatter to use, or <see langword="null"/> if none found.</returns>
        </member>
        <member name="T:MessagePack.Resolvers.CompositeResolver">
            <summary>
            Represents a collection of formatters and resolvers acting as one.
            </summary>
            <remarks>
            This class is not thread-safe for mutations. It is thread-safe when not being written to.
            </remarks>
        </member>
        <member name="M:MessagePack.Resolvers.CompositeResolver.Create(System.Collections.Generic.IReadOnlyList{MessagePack.Formatters.IMessagePackFormatter},System.Collections.Generic.IReadOnlyList{MessagePack.IFormatterResolver})">
            <summary>
            Initializes a new instance of an <see cref="T:MessagePack.IFormatterResolver"/> with the specified formatters and sub-resolvers.
            </summary>
            <param name="formatters">
            A list of instances of <see cref="T:MessagePack.Formatters.IMessagePackFormatter`1"/> to prefer (above the <paramref name="resolvers"/>).
            The formatters are searched in the order given, so if two formatters support serializing the same type, the first one is used.
            May not be null, but may be <see cref="M:System.Array.Empty``1"/>.
            </param>
            <param name="resolvers">
            A list of resolvers to use for serializing types for which <paramref name="formatters"/> does not include a formatter.
            The resolvers are searched in the order given, so if two resolvers support serializing the same type, the first one is used.
            May not be null, but may be <see cref="M:System.Array.Empty``1"/>.
            </param>
            <returns>
            An instance of <see cref="T:MessagePack.IFormatterResolver"/>.
            </returns>
        </member>
        <member name="M:MessagePack.Resolvers.CompositeResolver.CachingResolver.#ctor(MessagePack.Formatters.IMessagePackFormatter[],MessagePack.IFormatterResolver[])">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.Resolvers.CompositeResolver.CachingResolver"/> class.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicEnumAsStringResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicEnumAsStringResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.DynamicEnumResolver">
            <summary>
            EnumResolver by dynamic code generation, serialized underlying type.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicEnumResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicGenericResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.DynamicObjectResolver">
            <summary>
            ObjectResolver by dynamic code generation.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicObjectResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicObjectResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.DynamicObjectResolverAllowPrivate">
            <summary>
            ObjectResolver by dynamic code generation, allow private member.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.DynamicContractlessObjectResolver">
            <summary>
            ObjectResolver by dynamic code generation, no needs MessagePackObject attribute and serialized key as string.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.DynamicContractlessObjectResolverAllowPrivate">
            <summary>
            ObjectResolver by dynamic code generation, no needs MessagePackObject attribute and serialized key as string, allow private member.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.DynamicUnionResolver">
            <summary>
            UnionResolver by dynamic code generation.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicUnionResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.DynamicUnionResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.ExpandoObjectResolver">
            <summary>
            A resolver for use when deserializing MessagePack data where the schema is not known at compile-time
            such that strong-types can be instantiated.
            Instead, <see cref="T:System.Dynamic.ExpandoObject"/> is used wherever a MessagePack <em>map</em> is encountered.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.ExpandoObjectResolver.Instance">
            <summary>
            The resolver to use to deserialize into C#'s <c>dynamic</c> keyword.
            </summary>
            <remarks>
            This resolver includes more than just the <see cref="T:MessagePack.Formatters.ExpandoObjectFormatter"/>.
            </remarks>
        </member>
        <member name="F:MessagePack.Resolvers.ExpandoObjectResolver.Options">
            <summary>
            A set of options that includes the <see cref="F:MessagePack.Resolvers.ExpandoObjectResolver.Instance"/>
            and puts the deserializer into <see cref="F:MessagePack.MessagePackSecurity.UntrustedData"/> mode.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.NativeDateTimeResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.NativeDateTimeResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.NativeDecimalResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.NativeGuidResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.PrimitiveObjectResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.PrimitiveObjectResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.StandardResolver">
            <summary>
            Default composited resolver, builtin -> attribute -> dynamic enum -> dynamic generic -> dynamic union -> dynamic object -> primitive.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.StandardResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.StandardResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.ContractlessStandardResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.ContractlessStandardResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.StandardResolverAllowPrivate.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.StandardResolverAllowPrivate.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.ContractlessStandardResolverAllowPrivate.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.ContractlessStandardResolverAllowPrivate.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.StaticCompositeResolver">
            <summary>
            Singleton version of <see cref="T:MessagePack.Resolvers.CompositeResolver"/>, which can register a collection of formatters and resolvers to a single instance.
            </summary>
        </member>
        <member name="M:MessagePack.Resolvers.StaticCompositeResolver.Register(MessagePack.Formatters.IMessagePackFormatter[])">
            <summary>
            Initializes a singleton instance with the specified formatters.
            This method can only call before use StaticCompositeResolver.Instance.GetFormatter.
            If call twice in the Register methods, registered formatters and resolvers will be overridden.
            </summary>
            <param name="formatters">
            A list of instances of <see cref="T:MessagePack.Formatters.IMessagePackFormatter`1"/>.
            The formatters are searched in the order given, so if two formatters support serializing the same type, the first one is used.
            </param>
        </member>
        <member name="M:MessagePack.Resolvers.StaticCompositeResolver.Register(MessagePack.IFormatterResolver[])">
            <summary>
            Initializes a singleton instance with the specified formatters and sub-resolvers.
            This method can only call before use StaticCompositeResolver.Instance.GetFormatter.
            If call twice in the Register methods, registered formatters and resolvers will be overridden.
            </summary>
            <param name="resolvers">
            A list of resolvers to use for serializing types.
            The resolvers are searched in the order given, so if two resolvers support serializing the same type, the first one is used.
            </param>
        </member>
        <member name="M:MessagePack.Resolvers.StaticCompositeResolver.Register(System.Collections.Generic.IReadOnlyList{MessagePack.Formatters.IMessagePackFormatter},System.Collections.Generic.IReadOnlyList{MessagePack.IFormatterResolver})">
            <summary>
            Initializes a singleton instance with the specified formatters and sub-resolvers.
            This method can only call before use StaticCompositeResolver.Instance.GetFormatter.
            If call twice in the Register methods, registered formatters and resolvers will be overridden.
            </summary>
            <param name="formatters">
            A list of instances of <see cref="T:MessagePack.Formatters.IMessagePackFormatter`1"/>.
            The formatters are searched in the order given, so if two formatters support serializing the same type, the first one is used.
            </param>
            <param name="resolvers">
            A list of resolvers to use for serializing types for which <paramref name="formatters"/> does not include a formatter.
            The resolvers are searched in the order given, so if two resolvers support serializing the same type, the first one is used.
            </param>
        </member>
        <member name="M:MessagePack.Resolvers.StaticCompositeResolver.GetFormatter``1">
            <summary>
            Gets an <see cref="T:MessagePack.Formatters.IMessagePackFormatter`1"/> instance that can serialize or deserialize some type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of value to be serialized or deserialized.</typeparam>
            <returns>A formatter, if this resolver supplies one for type <typeparamref name="T"/>; otherwise <see langword="null"/>.</returns>
        </member>
        <member name="T:MessagePack.Resolvers.TypelessContractlessStandardResolver">
            <summary>
            Embeds the full name of .NET types for <see cref="T:System.Object"/> typed fields/collection items
            Preserves .NET <see cref="T:System.DateTime"/> timezone.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.TypelessContractlessStandardResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.TypelessContractlessStandardResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.TypelessContractlessStandardResolver.Resolvers">
            <summary>
            A *private* list of resolvers. If we ever want to expose any of these (so the user can adjust settings, etc.)
            then we must make this an instance collection instead of a static collection so that each consumer can have their own settings.
            </summary>
        </member>
        <member name="T:MessagePack.Resolvers.TypelessObjectResolver">
            <summary>
            Used for `object` fields/collections, ex: var arr = new object[] { 1, "a", new Model() };
            The runtime type of value in object field, should be covered by one of resolvers in complex/standard resolver.
            <see cref="T:MessagePack.Resolvers.TypelessObjectResolver"/> should be placed before DynamicObjectTypeFallbackResolver and <see cref="T:MessagePack.Formatters.PrimitiveObjectFormatter"/> in resolvers list.
            Deserializer uses Namespace.TypeName, AssemblyName to get runtime type in destination app, so that combination must be present in destination app.
            Serialized binary is valid MessagePack binary used ext-format and custom typecode(100).
            Inside ext - assembly qualified type name, and serialized object.
            </summary>
        </member>
        <member name="M:MessagePack.Resolvers.TypelessObjectResolver.GetFormatter``1">
            <inheritdoc />
        </member>
        <member name="F:MessagePack.Resolvers.ForceSizePrimitiveObjectResolver.Instance">
            <summary>
            The singleton instance that can be used.
            </summary>
        </member>
        <member name="F:MessagePack.Resolvers.ForceSizePrimitiveObjectResolver.Options">
            <summary>
            A <see cref="T:MessagePack.MessagePackSerializerOptions"/> instance with this formatter pre-configured.
            </summary>
        </member>
        <member name="T:MessagePack.SequencePool">
            <summary>
            A thread-safe, alloc-free reusable object pool.
            </summary>
        </member>
        <member name="F:MessagePack.SequencePool.Shared">
            <summary>
            A thread-safe pool of reusable <see cref="T:Nerdbank.Streams.Sequence`1"/> objects.
            </summary>
        </member>
        <member name="F:MessagePack.SequencePool.MinimumSpanLength">
            <summary>
            The value to use for <see cref="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength"/>.
            </summary>
            <remarks>
            Individual users that want a different value for this can modify the setting on the rented <see cref="T:Nerdbank.Streams.Sequence`1"/>
            or by supplying their own <see cref="T:System.Buffers.IBufferWriter`1" />.
            </remarks>
            <devremarks>
            We use 32KB so that when LZ4Codec.MaximumOutputLength is used on this length it does not require a
            buffer that would require the Large Object Heap.
            </devremarks>
        </member>
        <member name="F:MessagePack.SequencePool.arrayPool">
            <summary>
            The array pool which we share with all <see cref="T:Nerdbank.Streams.Sequence`1"/> objects created by this <see cref="T:MessagePack.SequencePool"/> instance.
            </summary>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <remarks>
            We use a <see cref="F:MessagePack.SequencePool.maxSize"/> that allows every processor to be involved in messagepack serialization concurrently,
            plus one nested serialization per processor (since LZ4 and sometimes other nested serializations may exist).
            </remarks>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <param name="maxSize">The maximum size to allow the pool to grow.</param>
            <devremarks>
            We allow 100 arrays to be shared (instead of the default 50) and reduce the max array length from the default 1MB to something more reasonable for our expected use.
            </devremarks>
        </member>
        <member name="M:MessagePack.SequencePool.#ctor(System.Int32,System.Buffers.ArrayPool{System.Byte})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequencePool"/> class.
            </summary>
            <param name="maxSize">The maximum size to allow the pool to grow.</param>
            <param name="arrayPool">Array pool that will be used.</param>
        </member>
        <member name="M:MessagePack.SequencePool.Rent">
            <summary>
            Gets an instance of <see cref="T:Nerdbank.Streams.Sequence`1"/>
            This is taken from the recycled pool if one is available; otherwise a new one is created.
            </summary>
            <returns>The rental tracker that provides access to the object as well as a means to return it.</returns>
        </member>
        <member name="P:MessagePack.SequencePool.Rental.Value">
            <summary>
            Gets the recyclable object.
            </summary>
        </member>
        <member name="M:MessagePack.SequencePool.Rental.Dispose">
            <summary>
            Returns the recyclable object to the pool.
            </summary>
            <remarks>
            The instance is cleaned first, if a clean delegate was provided.
            It is dropped instead of being returned to the pool if the pool is already at its maximum size.
            </remarks>
        </member>
        <member name="F:MessagePack.SequenceReader`1.usingSequence">
            <summary>
            A value indicating whether we're using <see cref="F:MessagePack.SequenceReader`1.sequence"/> (as opposed to <see cref="F:MessagePack.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.sequence">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:MessagePack.SequenceReader`1.memory"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.currentPosition">
            <summary>
            The position at the start of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.nextPosition">
            <summary>
            The position at the end of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.memory">
            <summary>
            Backing for the entire sequence when we're not using <see cref="F:MessagePack.SequenceReader`1.sequence"/>.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.moreData">
            <summary>
            A value indicating whether there is unread data remaining.
            </summary>
        </member>
        <member name="F:MessagePack.SequenceReader`1.length">
            <summary>
            The total number of elements in the sequence.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.#ctor(System.Buffers.ReadOnlySequence{`0}@)">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequenceReader`1"/> struct
            over the given <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.#ctor(System.ReadOnlyMemory{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:MessagePack.SequenceReader`1"/> struct
            over the given <see cref="T:System.ReadOnlyMemory`1"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.End">
            <summary>
            Gets a value indicating whether there is no more data in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Sequence">
            <summary>
            Gets the underlying <see cref="T:System.Buffers.ReadOnlySequence`1"/> for the reader.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Position">
            <summary>
            Gets the current position in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.CurrentSpan">
            <summary>
            Gets the current segment in the <see cref="P:MessagePack.SequenceReader`1.Sequence"/> as a span.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.CurrentSpanIndex">
            <summary>
            Gets the index in the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.UnreadSpan">
            <summary>
            Gets the unread portion of the <see cref="P:MessagePack.SequenceReader`1.CurrentSpan"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Consumed">
            <summary>
            Gets the total number of <typeparamref name="T"/>'s processed by the reader.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Remaining">
            <summary>
            Gets remaining <typeparamref name="T"/>'s in the reader's <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="P:MessagePack.SequenceReader`1.Length">
            <summary>
            Gets count of <typeparamref name="T"/> in the reader's <see cref="P:MessagePack.SequenceReader`1.Sequence"/>.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryPeek(`0@)">
            <summary>
            Peeks at the next value without advancing the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryRead(`0@)">
            <summary>
            Read the next value and advance the reader.
            </summary>
            <param name="value">The next value or default if at the end.</param>
            <returns>False if at the end of the reader.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.Rewind(System.Int64)">
            <summary>
            Move the reader back the specified number of items.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.GetNextSpan">
            <summary>
            Get the next segment with available data, if any.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.Advance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.AdvanceCurrentSpan(System.Int64)">
            <summary>
            Unchecked helper to avoid unnecessary checks where you know count is valid.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.AdvanceWithinSpan(System.Int64)">
            <summary>
            Only call this helper if you know that you are advancing in the current span
            with valid count and there is no need to fetch the next one.
            </summary>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryAdvance(System.Int64)">
            <summary>
            Move the reader ahead the specified number of items
            if there are enough elements remaining in the sequence.
            </summary>
            <returns><see langword="true"/> if there were enough elements to advance; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReader`1.TryCopyTo(System.Span{`0})">
            <summary>
            Copies data from the current <see cref="P:MessagePack.SequenceReader`1.Position"/> to the given <paramref name="destination"/> span.
            </summary>
            <param name="destination">Destination to copy to.</param>
            <returns>True if there is enough data to copy to the <paramref name="destination"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryRead``1(MessagePack.SequenceReader{System.Byte}@,``0@)">
            <summary>
            Try to read the given type out of the buffer if possible. Warning: this is dangerous to use with arbitrary
            structs- see remarks for full details.
            </summary>
            <remarks>
            IMPORTANT: The read is a straight copy of bits. If a struct depends on specific state of its members to
            behave correctly this can lead to exceptions, etc. If reading endian specific integers, use the explicit
            overloads such as <see cref="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int16@)"/>.
            </remarks>
            <returns>
            True if successful. <paramref name="value"/> will be default if failed (due to lack of space).
            </returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryRead(MessagePack.SequenceReader{System.Byte}@,System.SByte@)">
            <summary>
            Reads an <see cref="T:System.SByte"/> from the next position in the sequence.
            </summary>
            <param name="reader">The reader to read from.</param>
            <param name="value">Receives the value read.</param>
            <returns><see langword="true"/> if there was another byte in the sequence; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int16@)">
            <summary>
            Reads an <see cref="T:System.Int16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int16"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt16@)">
            <summary>
            Reads an <see cref="T:System.UInt16"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt16"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int32@)">
            <summary>
            Reads an <see cref="T:System.Int32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int32"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt32@)">
            <summary>
            Reads an <see cref="T:System.UInt32"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt32"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Int64@)">
            <summary>
            Reads an <see cref="T:System.Int64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.UInt64@)">
            <summary>
            Reads an <see cref="T:System.UInt64"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for an <see cref="T:System.UInt64"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Single@)">
            <summary>
            Reads a <see cref="T:System.Single"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Single"/>.</returns>
        </member>
        <member name="M:MessagePack.SequenceReaderExtensions.TryReadBigEndian(MessagePack.SequenceReader{System.Byte}@,System.Double@)">
            <summary>
            Reads a <see cref="T:System.Double"/> as big endian.
            </summary>
            <returns>False if there wasn't enough data for a <see cref="T:System.Double"/>.</returns>
        </member>
        <member name="M:MessagePack.StreamPolyfillExtensions.Read(System.IO.Stream,System.Span{System.Byte})">
            <summary>
            Reads from the stream into a memory buffer.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="buffer">The buffer to read directly into.</param>
            <returns>The number of bytes actually read.</returns>
        </member>
        <member name="M:MessagePack.StreamPolyfillExtensions.ReadAsync(System.IO.Stream,System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Reads from the stream into a memory buffer.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="buffer">The buffer to read directly into.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>The number of bytes actually read.</returns>
            <devremarks>
            This method shamelessly copied from the .NET Core 2.1 Stream class: https://github.com/dotnet/coreclr/blob/a113b1c803783c9d64f1f0e946ff9a853e3bc140/src/System.Private.CoreLib/shared/System/IO/Stream.cs#L366-L391.
            </devremarks>
        </member>
        <member name="M:MessagePack.StreamPolyfillExtensions.Write(System.IO.Stream,System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a span to the stream.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="buffer">The buffer to write.</param>
        </member>
        <member name="M:MessagePack.StreamPolyfillExtensions.WriteAsync(System.IO.Stream,System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Writes a span to the stream.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="buffer">The buffer to write.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="T:MessagePack.ThisLibraryExtensionTypeCodes">
            <summary>
            The extension type codes that this library defines for just this library.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityVector2">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityVector3">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityVector4">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityQuaternion">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityColor">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityBounds">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityRect">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityInt">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityFloat">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.UnityDouble">
            <summary>
            For Unity's UnsafeBlitFormatter.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.Lz4BlockArray">
            <summary>
            The LZ4 array block compression extension.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.Lz4Block">
            <summary>
            The LZ4 single block compression extension.
            </summary>
        </member>
        <member name="F:MessagePack.ThisLibraryExtensionTypeCodes.TypelessFormatter">
            <summary>
            For the <see cref="T:MessagePack.Formatters.TypelessFormatter"/>.
            </summary>
        </member>
        <member name="T:MessagePack.Utilities">
            <summary>
            Internal utilities and extension methods for various external types.
            </summary>
        </member>
        <member name="F:MessagePack.Utilities.IsMono">
            <summary>
            A value indicating whether we're running on mono.
            </summary>
        </member>
        <member name="M:MessagePack.Utilities.GetEntryEnumerator(System.Collections.IDictionary)">
            <summary>
            Gets an <see cref="T:System.Collections.IDictionary"/> enumerator that does not allocate for each entry,
            and that doesn't produce the nullable ref annotation warning about unboxing a possibly null value.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.Sequence`1">
            <summary>
            Manages a sequence of elements, readily castable as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <typeparam name="T">The type of element stored by the sequence.</typeparam>
            <remarks>
            Instance members are not thread-safe.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class
            that uses a private <see cref="T:System.Buffers.ArrayPool`1"/> for recycling arrays.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.MemoryPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="memoryPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.#ctor(System.Buffers.ArrayPool{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Nerdbank.Streams.Sequence`1"/> class.
            </summary>
            <param name="arrayPool">The pool to use for recycling backing arrays.</param>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength">
            <summary>
            Gets or sets the minimum length for any array allocated as a segment in the sequence.
            Any non-positive value allows the pool to determine the length of the array.
            </summary>
            <value>The default value is 0.</value>
            <remarks>
            <para>
            Each time <see cref="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)"/> or <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/> is called,
            previously allocated memory is used if it is large enough to satisfy the length demand.
            If new memory must be allocated, the argument to one of these methods typically dictate
            the length of array to allocate. When the caller uses very small values (just enough for its immediate need)
            but the high level scenario can predict that a large amount of memory will be ultimately required,
            it can be advisable to set this property to a value such that just a few larger arrays are allocated
            instead of many small ones.
            </para>
            <para>
            The <see cref="T:System.Buffers.MemoryPool`1"/> in use may itself have a minimum array length as well,
            in which case the higher of the two minimums dictate the minimum array size that will be allocated.
            </para>
            <para>
            If <see cref="P:Nerdbank.Streams.Sequence`1.AutoIncreaseMinimumSpanLength"/> is <see langword="true"/>, this value may be automatically increased as the length of a sequence grows.
            </para>
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.AutoIncreaseMinimumSpanLength">
            <summary>
            Gets or sets a value indicating whether the <see cref="P:Nerdbank.Streams.Sequence`1.MinimumSpanLength"/> should be
            intelligently increased as the length of the sequence grows.
            </summary>
            <remarks>
            This can help prevent long sequences made up of many very small arrays.
            </remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.AsReadOnlySequence">
            <summary>
            Gets this sequence expressed as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <returns>A read only sequence representing the data in this object.</returns>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.Length">
            <summary>
            Gets the length of the sequence.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.DebuggerDisplay">
            <summary>
            Gets the value to display in a debugger datatip.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.op_Implicit(Nerdbank.Streams.Sequence{`0})~System.Buffers.ReadOnlySequence{`0}">
            <summary>
            Expresses this sequence as a <see cref="T:System.Buffers.ReadOnlySequence`1"/>.
            </summary>
            <param name="sequence">The sequence to convert.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)">
            <summary>
            Removes all elements from the sequence from its beginning to the specified position,
            considering that data to have been fully processed.
            </summary>
            <param name="position">
            The position of the first element that has not yet been processed.
            This is typically <see cref="P:System.Buffers.ReadOnlySequence`1.End"/> after reading all elements from that instance.
            </param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)">
            <summary>
            Advances the sequence to include the specified number of elements initialized into memory
            returned by a prior call to <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/>.
            </summary>
            <param name="count">The number of elements written into memory.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)">
            <summary>
            Gets writable memory that can be initialized and added to the sequence via a subsequent call to <see cref="M:Nerdbank.Streams.Sequence`1.Advance(System.Int32)"/>.
            </summary>
            <param name="sizeHint">The size of the memory required, or 0 to just get a convenient (non-empty) buffer.</param>
            <returns>The requested memory.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Append(System.ReadOnlyMemory{`0})">
            <summary>
            Adds an existing memory location to this sequence without copying.
            </summary>
            <param name="memory">The memory to add.</param>
            <remarks>
            This *may* leave significant slack space in a previously allocated block if calls to <see cref="M:Nerdbank.Streams.Sequence`1.Append(System.ReadOnlyMemory{`0})"/>
            follow calls to <see cref="M:Nerdbank.Streams.Sequence`1.GetMemory(System.Int32)"/> or <see cref="M:Nerdbank.Streams.Sequence`1.GetSpan(System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Dispose">
            <summary>
            Clears the entire sequence, recycles associated memory into pools,
            and resets this instance for reuse.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.Reset">
            <summary>
            Clears the entire sequence and recycles associated memory into pools.
            This invalidates any <see cref="T:System.Buffers.ReadOnlySequence`1"/> previously produced by this instance.
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.MayContainReferences">
            <summary>
            A value indicating whether the element may contain references (and thus must be cleared).
            </summary>
        </member>
        <member name="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array">
            <summary>
            Gets the backing array, when using an <see cref="T:System.Buffers.ArrayPool`1"/> instead of a <see cref="T:System.Buffers.MemoryPool`1"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Start">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data starts.
            </summary>
            <remarks>This may be nonzero as a result of calling <see cref="M:Nerdbank.Streams.Sequence`1.AdvanceTo(System.SequencePosition)"/>.</remarks>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End">
            <summary>
            Gets the position within <see cref="P:System.Buffers.ReadOnlySequenceSegment`1.Memory"/> where the data ends.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingMemory">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.RemainingSpan">
            <summary>
            Gets the tail of memory that has not yet been committed.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner">
            <summary>
            Gets the tracker for the underlying array for this segment, which can be used to recycle the array when we're disposed of.
            Will be <see langword="null"/> if using an array pool, in which case the memory is held by <see cref="F:Nerdbank.Streams.Sequence`1.SequenceSegment.array"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.AvailableMemory">
            <summary>
            Gets the full memory owned by the <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.MemoryOwner"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length">
            <summary>
            Gets the number of elements that are committed in this segment.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.WritableBytes">
            <summary>
            Gets the amount of writable bytes in this segment.
            It is the amount of bytes between <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Length"/> and <see cref="P:Nerdbank.Streams.Sequence`1.SequenceSegment.End"/>.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.Next">
            <summary>
            Gets or sets the next segment in the singly linked list of segments.
            </summary>
        </member>
        <member name="P:Nerdbank.Streams.Sequence`1.SequenceSegment.IsForeignMemory">
            <summary>
            Gets a value indicating whether this segment refers to memory that came from outside and that we cannot write to nor recycle.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(System.Buffers.IMemoryOwner{`0})">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="memoryOwner">The memory and a means to recycle it.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Assign(`0[])">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="array">An array drawn from an <see cref="T:System.Buffers.ArrayPool`1"/>.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.AssignForeign(System.ReadOnlyMemory{`0})">
            <summary>
            Assigns this (recyclable) segment a new area in memory.
            </summary>
            <param name="memory">A memory block obtained from outside, that we do not own and should not recycle.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.ResetMemory(System.Buffers.ArrayPool{`0})">
            <summary>
            Clears all fields in preparation to recycle this instance.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.SetNext(Nerdbank.Streams.Sequence{`0}.SequenceSegment)">
            <summary>
            Adds a new segment after this one.
            </summary>
            <param name="segment">The next segment in the linked list.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.Advance(System.Int32)">
            <summary>
            Commits more elements as written in this segment.
            </summary>
            <param name="count">The number of elements written.</param>
        </member>
        <member name="M:Nerdbank.Streams.Sequence`1.SequenceSegment.AdvanceTo(System.Int32)">
            <summary>
            Removes some elements from the start of this segment.
            </summary>
            <param name="offset">The number of elements to ignore from the start of the underlying array.</param>
        </member>
        <member name="M:Nerdbank.Streams.Requires.Range(System.Boolean,System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/> if a condition does not evaluate to true.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Requires.FailRange(System.String,System.String)">
            <summary>
            Throws an <see cref="T:System.ArgumentOutOfRangeException"/> if a condition does not evaluate to true.
            </summary>
            <returns>Nothing.  This method always throws.</returns>
        </member>
        <member name="M:Nerdbank.Streams.Requires.NotNull``1(``0,System.String)">
            <summary>
            Throws an exception if the specified parameter's value is null.
            </summary>
            <typeparam name="T">The type of the parameter.</typeparam>
            <param name="value">The value of the argument.</param>
            <param name="parameterName">The name of the parameter to include in any thrown exception.</param>
            <returns>The value of the parameter.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="value"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Nerdbank.Streams.Requires.Argument(System.Boolean,System.String,System.String)">
            <summary>
            Throws an ArgumentException if a condition does not evaluate to true.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Requires.Argument(System.Boolean,System.String,System.String,System.Object)">
            <summary>
            Throws an ArgumentException if a condition does not evaluate to true.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Requires.Argument(System.Boolean,System.String,System.String,System.Object,System.Object)">
            <summary>
            Throws an ArgumentException if a condition does not evaluate to true.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Requires.Argument(System.Boolean,System.String,System.String,System.Object[])">
            <summary>
            Throws an ArgumentException if a condition does not evaluate to true.
            </summary>
        </member>
        <member name="T:Nerdbank.Streams.Verify">
            <summary>
            Common runtime checks that throw exceptions upon failure.
            </summary>
        </member>
        <member name="M:Nerdbank.Streams.Verify.Operation(System.Boolean,System.String)">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if a condition is false.
            </summary>
        </member>
    </members>
</doc>
